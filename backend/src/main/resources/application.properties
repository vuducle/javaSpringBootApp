spring.application.name=springBoot
# ----------------------------------------
# 1. PostgreSQL-Verbindungseinstellungen
# ----------------------------------------

# Der JDBC-URL (Standard-Port fÃ¼r PostgreSQL ist 5432)
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/nachweise_db}
# Dein PostgreSQL-Benutzername
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:nachweise_user}
# Dein PostgreSQL-Passwort
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:changeme}
# Der Treiber (hast du schon in Gradle hinzugefï¿½gt)
spring.datasource.driver-class-name=org.postgresql.Driver

server.port=8088
# ----------------------------
#JWT SECRET KEY
# ----------------------------
# JWT Secret Key (Muss sehr lang und komplex sein! Generiere einen 64-stelligen Hash!)
# Default fÃ¼r Development: Muss in Production via JWT_SECRET env variable gesetzt werden!
jwt.secret=${JWT_SECRET:your-super-secret-jwt-key-min-32-characters-for-development-only-change-in-production}
# Ablaufzeit des Tokens in Millisekunden (z.B. 24/60 Stunden)
jwt.expiration.ms=86400000
jwt.refresh.expiration.days=7

spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}

# ----------------------------------------
# Redis Optimierung fÃ¼r Sessions & Caching
# ----------------------------------------
# Verbindungs-Pool fÃ¼r bessere Performance
spring.redis.jedis.pool.max-active=20
spring.redis.jedis.pool.max-idle=10
spring.redis.jedis.pool.min-idle=5
spring.redis.jedis.pool.max-wait=-1ms
spring.redis.timeout=2000ms

# Session-Speicherung in Redis
spring.session.store-type=redis
# Session-ID Cookie-Name
spring.session.servlet.cookie.name=SESSION_ID
# HttpOnly Flag (verhindert JavaScript-Zugriff)
spring.session.servlet.cookie.http-only=true
# Same-Site Policy (CSRF-Schutz)
spring.session.servlet.cookie.same-site=strict
# Max-Age in Sekunden (14400 = 4 Stunden)
spring.session.timeout=14400s

# Redis Namespace fÃ¼r Sessions
spring.session.redis.namespace=spring:session
# Flushing Modus: IMMEDIATE fÃ¼r sofortige Persistierung
spring.session.redis.flush-mode=immediate

# Caching-Aktivierung
spring.cache.type=redis
# Cache TTL (wird Ã¼berschrieben durch cache-spezifische Configs)
spring.cache.redis.time-to-live=600000

app.frontend.url=${APP_FRONTEND_URL}
app.frontend.origins=${APP_FRONTEND_ORIGINS}
# ----------------------------------------
# 2. JPA/Hibernate Einstellungen
# ----------------------------------------

# Hibernate (der "Ãœbersetzer" von Java zu SQL)
# Production: 'validate' - Ã¼berprÃ¼ft dass Tabellen mit Entities Ã¼bereinstimmen
# Mit Flyway verwalten wir Schema-Ã„nderungen Ã¼ber Migrations
spring.jpa.hibernate.ddl-auto=validate

# ðŸš€ Hibernate Performance Tuning
# Fetch Size: Lade 50 Rows pro Query (statt 1)
spring.jpa.properties.hibernate.jdbc.fetch_size=50
# Batch Size: Batch 20 inserts/updates zusammen
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
# Lazy Load Optimierungen
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true
spring.jpa.properties.hibernate.use_reflection_optimizer=true
# Query IN Clause Optimierung
spring.jpa.properties.hibernate.query.in_clause_parameter_padding=true

# Flyway Database Migration
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true
spring.flyway.locations=classpath:db/migration
# For development, allow checksum validation to be more lenient
# Override in application-dev.properties and application-prod.properties
spring.flyway.validate-on-migrate=true

# Zeigt alle SQL-Befehle, die Spring an die DB sendet (sehr nÃ¼tzlich zum Debuggen)
spring.jpa.show-sql=false

# Enable debug logging for Spring Security
logging.level.org.springframework.security=INFO
logging.level.org.example.springboot=INFO
logging.level.org.flywaydb=INFO

# ----------------------------------------
# Mail Server Settings
# ----------------------------------------
spring.mail.host=${SPRING_MAIL_HOST:smtp.hostinger.com}
spring.mail.port=${SPRING_MAIL_PORT:587}
spring.mail.username=${SPRING_MAIL_USERNAME}
spring.mail.password=${SPRING_MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_STARTTLS_ENABLE:true}
spring.mail.properties.mail.smtp.starttls.required=${SPRING_MAIL_STARTTLS_REQUIRED:true}


# Image upload settings
image.max-width=500
image.max-height=500
# Quality: 0.0 - 1.0
image.quality=0.75

# ----------------------------------------
# Email Verification Settings
# ----------------------------------------
# Token expiration in hours (default: 24 hours)
email.verification.token.expiration.hours=24

spring.main.allow-bean-definition-overriding=true

# ----------------------------------------
# Database Backup Settings
# ----------------------------------------
# Backups aktivieren/deaktivieren
backup.enabled=${BACKUP_ENABLED:true}

# Backup-Verzeichnis (absoluter Pfad)
# Standard fÃ¼r Development: ./backups (relativ zum Backend-Verzeichnis)
# Production: Setze via BACKUP_DIRECTORY environment variable, z.B. /var/backups
backup.directory=${BACKUP_DIRECTORY:./backups}

# Alte Backups nach X Tagen lï¿½schen (default: 30 Tage)
backup.retention.days=${BACKUP_RETENTION_DAYS:30}

# Cron-Expression fï¿½r automatische Backups
# Standard: Jeden Sonntag um 2:00 Uhr
# Format: Sekunde Minute Stunde Tag Monat Wochentag
backup.schedule.cron=${BACKUP_SCHEDULE_CRON:0 0 2 * * 0}

# Beispiele:
# 0 0 2 * * 0        = Jeden Sonntag um 2:00 Uhr
# 0 0 3 * * *        = Tï¿½glich um 3:00 Uhr
# 0 0 0 1 * *        = Am 1. Tag jeden Monats um 0:00 Uhr
# 0 0 */6 * * *      = Alle 6 Stunden